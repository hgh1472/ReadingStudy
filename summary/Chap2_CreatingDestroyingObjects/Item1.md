# [ITEM 1] 생성자 대신 팩터리 메서드를 고려하라

클래스는 생성자와 별도로 **정적 팩터리 메서드**를 제공할 수 있다. 이는 클래스의 인스턴스를 반환하는 단순한 static 메서드이다.

아래 코드는 boolean 타입의 박싱 클래스인 Boolean의 코드이다. 기본 타입인 boolean 값을 받아 Boolean 객체 참조로 변환해준다.

```java
public static Boolean valueOf(boolean b) {
		return b ? Boolean.TRUE : Boolean.FALSE;
}
```

클래스는 클라이언트에 public 생성자 대신 정적 팩터리 메서드를 제공할 수 있다.

## 정적 팩터리 메서드의 장점

### 이름을 가질 수 있다.

생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다.

예를 들어 `BigInteger(int, int, Random)`과 `BigInteger.probablePrime` 중 어느 쪽이 ‘값이 소수인 BigInteger를 반환한다’는 의미를 더 잘 설명하는지는 후자일 것이다.

### 호출될 때 마다 인스턴스를 새로 생성하지는 않아도 된다.

불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 대표적으로 위의 예시 코드인 `Boolean.valueOf(boolean)` 메서드는 객체를 아예 생성하지 않는다. 플라이웨이트 패턴도 이와 비슷한 기법이다.



⚖️ 플라이웨이트 패턴?

플라이웨이트 패턴은 **재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화하는 구조 패턴**이다. 자주 변하는 속성과 변하지 않는 속성을 분리하고 변하지 않는 속성을 캐시하여 재사용해 메모리 사용을 줄이는 방식이다.

---
**Issue 내용**
> 인스턴스 통제는 플라이웨이트 패턴의 근간이 되며, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다는 게 무슨 뜻인가요?
>

일단 제가 생각한 책에서의 '인스턴스 통제'는 정적 팩터리 메서드를 통해 인스턴스 반환을 결정하는 것이라고 생각해요.

이 때 플라이웨이트 패턴은 재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화하는 패턴이라고 합니다. 자주 변하는 속성과 변하지 않는 속성을 분리하고 변하지 않는 속성을 캐시하여 재사용해 메모리 사용을 줄이는 방식으로 사용됩니다. 즉, 변하지 않는 속성은 굳이 새로 생성하지 않고 반환하고 변하는 속성은 새로 생성하여 반환하는 식으로 보입니다.

따라서 정적 팩터리 메서드를 사용한 '인스턴스 통제'를 통해 **변하는 속성과 변하지 않는 속성에 따라 인스턴스를 반환할 수 있습니다.**

그리고 열거 타입은 enum 클래스로 상수를 나타내는 클래스라고 할 수 있습니다. 예를 들어 우리는 가끔 다음과 같은 형식으로 클래스 내에서 상수를 사용합니다.

```java
class Adder {
    private final static int plus = 1;
    private final static int minus = 2;
    // ...
}
```

위처럼 사용하는 대신 아예 상수만을 다루는 enum 타입 클래스가 존재합니다.

```java
enum Calculation {
    ADD(1),
    MINUS(2);
    private final int command;
    Calculation(int command) {
        this.command = command;
    }

    public int getValue() {
        return command;
    }
}
```

이 때 enum 클래스는 상수 값과 같이 유일하게 하나의 인스턴스가 생성되어 사용됩니다. enum의 상수값은 힙 영역에 저장됩니다. 따라서 String처럼 스택 영역에 있는 변수들이 힙 영역에 있는 데이터의 주소값을 저장함으로써 참조 형태를 띄게 됩니다. 그리고 enum은 싱글톤 형태로 만들어진다고 합니다.

---

이처럼 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지 철처히 통제할 수 있다. 이런 클래스를 인스턴스 통제 클래스라 한다. 인스턴스를 통제하면 클래스를 싱글턴으로 만들거나 인스턴스화 불가로 만들 수도 있다. 또한 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.
### 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

반환할 객체의 클래스를 자유롭게 선택할 수 있게하는 엄청난 유연성을 이용할 수 있다. 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있다.

### 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다. 예를 들어, EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리만 제공한다. 원소가 64개 이하면 원소들을 long 변수 하나로 관리하는 RegularEnumSet의 인스턴스를, 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.

클라이언트는 이 두 클래스의 존재를 모른다. 클라이언트는 팩터리가 건제누는 객체가 어느 클래스의 인스턴스인지 알 수도 없고 알 필요도 없다. EnumSet의 하위 클래스이기만 하면 된다.

### 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

이 말의 뜻을 이해하기가 쉽지 않다.


잘 이해가 되지않아 스터디에서 얘기가 나왔는데, 이에 대해 설명한 유튜브 영상이 있다.

[백기선 - [이팩티브 자바] #1 생성자 대신 static 팩토리 메소드를 고려해 볼 것](https://www.youtube.com/watch?v=X7RXP6EI-5E)

```java
static {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
}

public static Connection getConnection() throws SQLException {
    Connection conn = null;
    try {
        conn = DriverManager.getConnection(url, user, password);
    } catch (SQLException e) {
        System.out.println("커넥션 생성 오류");
        e.printStackTrace();
    }
    return conn;
}
```

위 코드에서 Class.forName(String)에 의해 Driver 클래스가 클래스로더에 의해 로드되면 자체적으로 인스턴스를 만들어 DriverManager 클래스에 등록이 된다. 이는 파라미터로 받은 String에 해당하는 클래스를 로딩하며 해당 클래스가 로드될 때 static 필드의 내용이 실행되는 것을 이용해 자기 자신을 DriverManager 클래스에 등록한다.

즉, JDBC에서는 사용할 DBMS에 맞는 드라이버 이름을 넘겨주면 자체적으로 인스턴스를 만들어 DriverManager.registerDriver에 의해 등록된다.

이 때 getConnection 메서드를 작성한다고 할 때, Driver 인터페이스의 구현체들은 작성시점에 존재하지 않을 수도 있다.

확실하진 않지만 정리하자면, 정적 팩터리 메서드에서의 반환 객체는 이후에 추가로 생성할 수도 있다는 뜻으로 여겨진다.

## 정적 팩터리 메서드의 단점

### 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

정적 팩터리 메서드를 이용하면 상속이 불가능하다. public이나 protected 생성자가 존재하지 않기 때문이다.

### 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다. 따라서 API 문서를 잘 작성하고 메서드 이름도 널리 알려진 규약을 따라 짓는 식으로 문제를 완화해야 한다.
